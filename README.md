# dismathportfolio-harleyorines
dismathportfolio-harleyorines created by Classroom for GitHub

Stuff I Learned...

## WEEK 1:

- DisMath deals more with logical truths and that it requires minimal computations.
- It isn't boring at all as opposed to what I first thought.
- The definition and examples of propositions
- Logical connectives

## WEEK 2:

- Realization: You don't just breeze through the course. You have to pay attention and think.
- Nested logical connectives
- Implication can turn out to be quite confusing.
- Truth tables are easy to learn. I prefer using it more than equivalences for proving.

## WEEK 3:

- An argument's validity doesn't tell us anything about its truth value.
- Fallacies are invalid arguments.
- Our class was introduced to quantifiers such as universal and existential.
- Universal quantifiers tell us that the premise is true for ALL possible cases. To disprove, state that there exists ¬premise.
- Existential quantifiers tells us the premise holds true for at least one instance. To disprove, show ¬premise for all possible cases.

## WEEK 4:

- Rules of Inference are yet another set of tools for proving.
- We can use atomic propositions to break down a problem according to important keywords then proceed with proving.
- We were introduced to the methods of proving such as direct proof and proof by contrapositive.

## WEEK 5:

- For week 5, we started off from where the discussion ended from the previous week and discussed other proving methods.
- Proving via contradiction is done by showing that the negation of a premise leads to a contradiction.
- I have previously encountered mathematical induction in my ENGALG2 course. It consists of the basis step and inductive step.
- Recursive functions can be tricky at first. All there is to remember is that the next value for the function depends on the previous value.

## WEEK 6:

- The basics regarding sets.
- I agree with our professor telling us that this particular session is a temporary breather from all the difficult topics so far.
- Union, intersection, and symmetrical difference
- Set identities. I told myself that in order to learn these new set of rules, I must indoctrinate myself with either logical equivalences or set identities then make do with the other by means of their patterns. This works because of their similarity.

## WEEK 7

- A function is a relationship of sets of variables wherein only one element is assigned to each input value.
- The range of a function are the actual occuring values.
- The domain describes input while codomain describes all possible output.
- The three types of functions; injective, surjective, and bijective (I learned that it is best to use these names for the types because one-to-one and one-to-one correspondence can lead to a problem of ambiguity).

## WEEK 8

- An algorithm is a finite set of defined instructions intended for carrying out computations and processes.
- A pseudocode can be considered as a informal piece of programming code which is more suited to human reading.
- In creating an algorithm, it is a requisite to identify the preconditions and postconditions.
- People who are well-versed in programming may actually have an upper hand when it comes to these lessons.

## WEEK 9

- Search Algorithms and Sorting Algorithms
- Linear Search involves scanning a list for the element input and showing the location / index once a match is found. Outputs "cannot be found" or a negative value when the element input we are looking for is not in the list.
- Binary Search repeatedly splits the list based on the element input and shows the location / index once the element is found in the list. That is, if the list cannot be further split.
- That dance video for bubble sort.
- In bubble sorting we have comparisons of adjacent elements in which one loop of comparisons sorts at least one element in its proper position. This is done until all elements are sorted.
- Insertion sort. :3
- Greedy algorithm makes use of the best possible next step in a process or computation.

## WEEK 10

- The time complexity of an algorithm tells us of its efficiency. The question being asked here is how many steps does an algorithm take before arriving at an output?
- A less complex program is always favored more than a more complex program.
- For growth of functions, the big guys were discussed (BIG-O, BIG-OMEGA, BIG-THETA).
- Big O notation is the upper bound of a function, while Big Omega is the lower bound. Big Theta is both the lower and upper bound.
- Perhaps a useful technique in determining the complexity of a function is to get hold of its degree, which can give us an idea of its upper and lower bound. We provide witness C and k to prove our claim.
- Comparisons made in an algorithm can be traced and counted altogether using an iteration table.

## WEEK 11

